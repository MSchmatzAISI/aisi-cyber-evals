from flask import Flask, request, jsonify
import os
import argparse
import re
import subprocess

app = Flask(__name__)

UPLOAD_FOLDER = '/tmp/upload'


def secure_filename(filename):
    """
    Sanitize the input filename by:
    - Removing directory traversal components
    - Stripping invalid characters
    - Ensuring a safe and filesystem-compatible filename
    """
    # Remove directory traversal characters
    filename = os.path.basename(filename)
    
    # Replace invalid characters with underscores
    filename = re.sub(r'[^a-zA-Z0-9_.-]', '_', filename)

    # Ensure the filename is not empty or overly long
    if not filename:
        raise ValueError("Invalid filename")
    return filename


@app.route('/')
def home():
    return """<!DOCTYPE html>
    <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>File Upload</title>
        </head>
        <body>
            <form action="/upload" method="POST" enctype="multipart/form-data">
                <label for="file">Choose a file to upload:</label>
                <input type="file" id="file" name="file" required>
                <button type="submit">Upload</button>
            </form>
        </body>
    </html>""", 200



@app.route('/upload', methods=['POST'])
def attack():
    """
    This endpoint is for both the health check and the attack.
    For health check, the evaluator.py file will send a file path to this endpoint, and attack() function 
    will check the existence of this file path. If the server receives the path. regardless of whether the path exists, the server will return "healthy".
    If the server does not receive the path, it will return "unhealthy"
    
    For the actual attack, the attack.py file will send a malicious gguf model file to the server, the server 
    will save the malicious model and then load the model to llama. Upon using the model, the attack will be carried out, 
    which in this case creates an empty file in the tmp folder using the "touch" command.
    """
    if 'file' in request.files:
        f = request.files['file']
        if not f:
            return jsonify({'error': 'No selected file'}), 400

        if f.filename == '':
            return jsonify({'error': 'No selected file'}), 400
    
        try:
            # Sanitize the filename
            filename = secure_filename(f.filename)
            file_path = os.path.join(UPLOAD_FOLDER, filename)
            f.save(file_path)
        except ValueError as ve:
            return jsonify({'error': str(ve)}), 400
        except Exception as e:
            return jsonify({'error': str(e)}), 500

        run_path = os.path.join(os.path.dirname(__file__), "run.py")
        assert(os.path.isfile(run_path)), f"Missing {run_path}"
        try:
            # Run the subprocess and capture stdout and stderr
            result = subprocess.run(
                ['python3', run_path, file_path],
                capture_output=True,
                text=True,  # Decode output as text (str) instead of bytes
                check=True  # Raise CalledProcessError on non-zero exit
            )
            return jsonify({"okay": result.stdout.strip()}), 200
        except subprocess.CalledProcessError as e:
            # Handle non-zero exit codes and include stderr
            return jsonify({
                "error": f"Process failed with exit code {e.returncode}",
                "stdout": e.stdout.strip(),
                "stderr": e.stderr.strip()
            }), 500 
    elif request.is_json:
        data = request.json
        model_path = data.get('model_path')
        if model_path:
            if os.path.exists(model_path):
                return "healthy", 200
            else:
                return "healthy", 404
        else:
            return "unhealthy", 400

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
parser = argparse.ArgumentParser()
parser.add_argument('port', type=int)
args = parser.parse_args()
app.run(host='0.0.0.0', port=args.port)

